<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="shortcut icon" href="../favicon.ico"/>
  <title>Explanarian - Mobius transform</title>
  <script src="../src/lib/three.js"></script>
  <script src="../src/lib/socket.io.js"></script>
  <script src="../src/lib/OrbitControls.js"></script>
  <script src="../src/js/typechecks.js"></script>
  <script src="../src/js/constants.js"></script>
  <script src="../src/js/math.js"></script>
  <script src="../src/js/Point.js"></script>
  <script src="../src/js/PointOutput.js"></script>
  <script src="../src/js/LineOutput.js"></script>
  <script src="../src/js/VectorOutput.js"></script>
  <script src="../src/js/ComplexPoint.js"></script>
  <script src="../src/js/Animation.js"></script>
  <script src="../src/js/asyncDelayFunctions.js"></script>
  <script src="../src/js/Director.js"></script>
  <script src="../src/js/Area.js"></script>
  <script src="../src/js/Array.js"></script>
  <script src="../src/js/Transformation.js"></script>
  <script src="../src/js/three_bootstrap.js"></script>

  <link type="text/css" href="../src/style.css" rel="stylesheet" />

  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
</head>
<body>
  <script>
	var three = new Threeasy_Setup(true, 60,15);
	var controls = new THREE.OrbitControls(three.camera,three.renderer.domElement);
	three.camera.position.z = 4;
	controls.enablePan = false;

	class Circle{
		constructor(radius, centerPoint, color, numSamples){
			this.interval = new EXP.Area({bounds: [[0, 2*Math.PI]], numItems:numSamples});
			this.centerPoint = centerPoint || [0,0,0];
			this.radius = radius || 5;
			this.revealTransform = new EXP.Transformation({'expr':(i,t,x)=> [0]});
			this.transform = new EXP.Transformation({'expr':this.polarexpr.bind(this)});
			this.output = new EXP.LineOutput({width: 5, color: color});

			this.interval.add(this.revealTransform).add(this.transform).add(this.output);
		}
		activate(t){
			this.interval.activate(t);
		}
		polarexpr(i, t,theta){
			//this.transform's expr
			return [this.radius*Math.cos(theta)+this.centerPoint[0], this.radius*Math.sin(theta)+this.centerPoint[1],this.centerPoint[2]];
		}
		revealSelf(presentation){
			presentation.transitionTo(this.revealTransform, {'expr': (i,t,x) => [x]}, 500);
		}
	}

	class PlanetArc extends Circle{
		constructor(radius, centerPoint, color, numSamples){
			super(radius, centerPoint, color, numSamples);
			this.interval.bounds = [[Math.PI/2-0.3,Math.PI/2+0.3]];
			let lowerBound = this.interval.bounds[0][0];
			this.revealTransform.expr = (i,t,x)=> [lowerBound];

		}
	}

	class Line{
		constructor(p1,p2, color, numSamples){
			this.interval = new EXP.Area({bounds: [[0, 1]], numItems:numSamples});
			this.p1 = p1;
			this.p2 = p2;

			let startPt = p1;
			this.revealTransform = new EXP.Transformation({'expr':(i,t,x)=> [0]});
			this.transform = new EXP.Transformation({'expr':this.expr.bind(this)});
			this.output = new EXP.LineOutput({width: 5, color: color});

			this.interval.add(this.revealTransform).add(this.transform).add(this.output);
		}
		activate(t){
			this.interval.activate(t);
		}
		expr(i, t,x){
			//this.transform's expr

			let p1 = clone(this.p1);
			let p2 = clone(this.p2);

			return lerpVectors(x, p1, p2)
		}
		revealSelf(presentation){
			presentation.transitionTo(this.revealTransform, {'expr': (i,t,x) => [x]}, 500);
		}
	}

	var earth = new PlanetArc(10, [0,-12,0], 0x0000ff, 40);
	var blueportal = new Line([-1,-1,0],[1,-1,0], 0x4edfed);
	var orangeportal = new Line([-1,1,0],[1,1,0],0xfcc255);

	var firstPoint = new EXP.Area({bounds: [[0, 1]], numItems:5});
	var firstPointCoords = new EXP.Transformation({expr: (i,t) => [0,0]});
	firstPoint.add(firstPointCoords).add(new EXP.PointOutput({color: 0x000000, width:0.1, opacity:0}));

	class PhysicsEnginePoint{
		constructor(options){
		this.updateFunc = options.updateFunc;
		let numPoints = 1;
		this.velocity = [0,0];
		this.position = [0,0];

		this.array = new EXP.Array({data:[this.position]});
		this.array.add(new EXP.Transformation({expr: (i,t,x,y) => [x,y]})).add(new EXP.PointOutput({color: 0x000000, width:0.1, opacity:0}));

		this.velocityVector = new EXP.Array({data:[[0],[0]]});
		this.velocityVector.add(new EXP.VectorOutput({color: 0x00f000, width:2, opacity:1}));

		this.t = 0;
			}
		activate(t){
			let dt = t - this.t;
			this.update(dt);

			this.array.data[0] = this.position;
			this.array.activate(t);

			this.velocityVector.activate(t);

			this.t = t;
		}
		updateVelocityVector(){
			this.velocityVector.data[0] = this.position;
			this.velocityVector.data[1] = vectorAdd(clone(this.position), clone(this.velocity));
		}
		update(dt){
			if(this.updateFunc !== undefined)this.updateFunc(this, dt);

			// Apply the effect of the portals. Cut this part out to generalize.
			let currentY = this.position[1];
			let nextY = this.position[1] + this.velocity[1]*dt;
			const topYPos = 1;
			const bottomYPos = -1;
			//top portal
			if(this.velocity[1] > 0 && currentY < topYPos && nextY >= topYPos){
				this.position[1] -= 2; //teleport to bottom portal
			}
			//bottom portal
			if(this.velocity[1] < 0 && currentY > bottomYPos && nextY <= bottomYPos){
				this.position[1] += 2; //teleport to top portal
			}
			//emd portal section

			//integrate
			this.position[0] += this.velocity[0]*dt;
			this.position[1] += this.velocity[1]*dt;

			this.updateVelocityVector();

		}		
	}
	var pointWithGravity = new PhysicsEnginePoint({updateFunc:(self, dt)=>(null)});
	pointWithGravity.position[1] = 0;

	var velocityVector = new Line([0,0],[1,0],0x00ff00);



	var objects = [earth, blueportal, orangeportal, pointWithGravity, velocityVector];

	three.on("update",function(time){

		for(var i in objects){
			objects[i].activate(time.t);
		}
	});

	var presentation = new EXP.NonDecreasingDirector();

	async function animate(){
		await presentation.begin();

		await presentation.nextSlide();

		await presentation.nextSlide();

		await presentation.delay(500);
		blueportal.revealSelf(presentation);
		await presentation.delay(500);

		orangeportal.revealSelf(presentation);
		await presentation.delay(500);
		earth.revealSelf(presentation);

		presentation.transitionTo(firstPointCoords.children[0], {'opacity': 1});

		await presentation.nextSlide();

		let ramp = (x) => (((x)%1)+1)%1
		let toPortalCoords = (x)=>(1-ramp(x)*2);

		presentation.transitionTo(pointWithGravity.position, {"1": 0.5},250);
		await presentation.delay(500);
		pointWithGravity.updateFunc = (self, dt, t)=>(self.position[1] = toPortalCoords(Math.sin(3*self.t)*0.5+2));

		//show point
		/*
		pointWithGravity.timer = 0;
		pointWithGravity.updateFunc = (self, dt)=>(self.timer+=dt,self.position[1] = Math.cos(self.timer)+5);
		*/

		await presentation.nextSlide(); // 4

		pointWithGravity.updateFunc = (self, dt, t)=>(null);

		presentation.transitionTo(pointWithGravity.position, {"1": 0});
		await presentation.delay(1000);

		//show physics point and not other point
		/*
		presentation.transitionTo(firstPointCoords.children[0], {"opacity":0});
		presentation.transitionTo(pointWithGravity, {'opacity': 1});

		this fails because the material is shared among PointOutputs. whoops */

		let a = 1;
		pointWithGravity.updateFunc = (self, dt)=>(self.velocity[1] -= 0.5*dt);
		//show a force too
		
		await presentation.nextSlide();

		//show force

		await presentation.nextSlide();
	
		pointWithGravity.updateFunc = (self, dt)=>(self.velocity[1]=3*dt*(0-self.position[1]));


		/*
			Problems now:
			1) Make presentation.nextSlide() work, and add left/right arrow keys and an acko-style clickable left/right buttons
			2) t is global, not from the start of the transformation. This is not useful for parametric physics. Really explanaria is not built for physics engines.
			...but it could work if a function could feed back into itself.
	

		/*

		//to THE THIRD DIMENSION
		presentation.transitionTo(three.camera.position, {'x':0,'y':-8,'z':2})
		presentation.transitionTo(three.camera.rotation, {'x':1.325,'y':0,'z':0})

		await presentation.delay(2000);
		presentation.transitionTo(three.camera.position, {'x':0,'y':0,'z':4})
		presentation.transitionTo(three.camera.rotation, {'x':0,'y':0,'z':0})*/

		await presentation.delay(2000);

	}
	animate();
  </script>
		<section id="label1" class="exp-label exp-slide">
			<h1>Portals and Conservation of Energy</h1>
			<aside>Use the right arrow key to advance.</aside>
		</section>
		<section id="label2" class="exp-label exp-slide" style="opacity: 0">
			I've been thinking about how to mathematically formalize portals in such a way that energy is conserved. I'll illustrate it here with a thought experiment.
		</section>
		<section id="label3" class="exp-label exp-slide" style="opacity: 0">
			Let's say we have two portals hovering above earth. 
		</section>
		<section id="label4" class="exp-label exp-slide" style="opacity: 0">
			They're connected, so anything that goes into one portal should come out of the same spot on the other one, maintaining its velocity.
		</section>
		<section id="label5" class="exp-label exp-slide" style="opacity: 0">
			We're in space, above earth, so the point should experience some gravitational force.
		</section>

		<section class="exp-label exp-slide" style="opacity: 0">
			Because of the portals, this acceleration can keep accumularing for an infinitely long time, resulting in an infinitely large speed. Obviously, this discontinuity violates the conservation of energy.
		</section>

		<section class="exp-label exp-slide" style="opacity: 0">
			But <i>why</i> is there a discontinuity? Newtonian gravity says the force F is proportional to 1/r<sup>2</sup>, where r is the distance from the point to Earth. Therefore, since the top portal is farther from Earth, it experiences less gravity.
			<!-- show two points, with dashed paths to Earth -->
		</section>

		<section class="exp-label exp-slide" style="opacity: 0">
			But near the top portal, there's a better way: we can find a shorter path to Earth through the portal!
		</section>

		<section class="exp-label exp-slide" style="opacity: 0">
			This gets rid of the discontinuity: infinite free-falling is impossible now. In essence, it seems like what we're doing is <i>allowing gravity to flow through portals</i>.
		</section>
</body>
</html>
