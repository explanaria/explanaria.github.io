<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="shortcut icon" href="../../favicon.ico"/>
  <title>Explanarian - Definition of a sine wave</title>
  <script src="../../src/lib/three.js"></script>
  <script src="../../src/lib/OrbitControls.js"></script>
  <script src="../../build/explanaria-bundle.js"></script>

  <link type="text/css" href="../../src/style.css" rel="stylesheet" />

  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
</head>
<body>
  <script>
	var three = new EXP.Threeasy_Environment(true, 120,10);
	var controls = new THREE.OrbitControls(three.camera,three.renderer.domElement);

	three.camera.position.set(0,0,10);
	three.camera.lookAt(new THREE.Vector3(0,0,0));

	console.log("Loaded.");

	let lightblue = 0x0070f0;
	let orangered = 0xff7070;
	let lightgreen = 0x70ff70;


	var params = {};
	params.radius=4;
	params.freq = 2;

	var circle = new EXP.Area({bounds: [[0,2*Math.PI],[0,params.radius]],numItems:[17,2]});
	var circleTransformation = new EXP.Transformation({'expr': (i,t,theta,r) => [r*Math.cos(params.freq*t+theta),r*Math.sin(params.freq*t+theta),0]});
	var transformCircle = new EXP.Transformation({'expr': (i,t,x,y,z) => [x,y,z]});
	var output1 = new EXP.LineOutput({width:5,color:lightblue,opacity:1});

	circle.add(circleTransformation).add(transformCircle).add(output1);

	var circle2 = new EXP.Area({bounds: [[0,2*Math.PI]],numItems:60});
	var circleTransformation2 = new EXP.Transformation({'expr': (i,t,theta) => [params.radius*Math.cos(params.freq*t+theta),params.radius*Math.sin(params.freq*t+theta),0]});
	var transformCircle2 = new EXP.Transformation({'expr': (i,t,x,y,z) => [x,y,z]});
	var output2 = new EXP.LineOutput({width:5,color:lightblue,opacity:1});

	circle2.add(circleTransformation2).add(transformCircle2).add(output2);

	var circle3 = new EXP.Area({bounds: [[0,2*Math.PI]],numItems:1});
	var circleTransformation3 = new EXP.Transformation({'expr': (i,t,theta) => [params.radius*Math.cos(params.freq*t),params.radius*Math.sin(params.freq*t),0]});
	var transformCircle3 = new EXP.Transformation({'expr': (i,t,x,y,z) => [x,y,z]});
	var output3 = new EXP.PointOutput({width:0.5,color:orangered,opacity:1});

	circle3.add(circleTransformation3).add(transformCircle3).add(output3);

	class twoPointLine{
		constructor(funcA,funcB, col){

			let pt1 = funcA;
			let pt2 = funcB;

			this.area = new EXP.Area({bounds: [[0,1]],numItems:2});
			this.revealTransform = new EXP.Transformation({'expr': (i,t,x) => [0]});
			this.lineDefinition = new EXP.Transformation({'expr': (i,t,x) => EXP.Math.vectorAdd(EXP.Math.multiplyScalar((1-x),funcA(i,t,x)),EXP.Math.multiplyScalar(x,funcB(i,t,x)))});
			this.linePostTransform = new EXP.Transformation({'expr': (i,t,x,y,z) => [x,y]});
			this.out = new EXP.LineOutput({width:5,color:col});
			this.area.add(this.revealTransform).add(this.lineDefinition).add(this.linePostTransform).add(this.out);
		}
		activate(time){
			this.area.activate(time);
		}	
		reveal(){
			EXP.TransitionTo(this.revealTransform,{'expr': (i,t,x) => [x]},800);
		}	
	}	
	
	var hypotenuse = new twoPointLine( (i,t,x) => [0,0], (i,t,x) => [params.radius*Math.cos(params.freq*t),params.radius*Math.sin(params.freq*t)], orangered);
	var xaxis = new twoPointLine( (i,t,x) => [params.radius*Math.cos(params.freq*t),0], (i,t,x) => [0,0], orangered);
	var yaxis = new twoPointLine( (i,t,x) => [params.radius*Math.cos(params.freq*t),params.radius*Math.sin(params.freq*t)], (i,t,x) => [params.radius*Math.cos(params.freq*t),0], lightgreen);

	let angleR = 0.5;
	var angleMeasure = new EXP.Area({bounds: [[0,2*Math.PI]],numItems:[30]});
	var circleTransformation2 = new EXP.Transformation({'expr': (i,t,realTheta) => {
			let pointTheta = (params.freq*t) % (2*Math.PI);
			var theta = realTheta;
			if(realTheta > pointTheta)theta = pointTheta;
		return [angleR*Math.cos(theta),angleR*Math.sin(theta),0]
		}});
	var transformCircle2 = new EXP.Transformation({'expr': (i,t,x,y,z) => [x,y,z]});
	var outputAngle = new EXP.LineOutput({width:5,color:orangered,opacity:0});

	angleMeasure.add(circleTransformation2).add(transformCircle2).add(outputAngle);


	//ok now back to the actual animation

	three.on("update",function(time){
		[circle,circle2,circle3,hypotenuse,xaxis,yaxis, angleMeasure].map(i => i.activate(time.t));
	});

	async function animate(){

		//Rotating circle.

		await EXP.delay(500);

		[output1,output2].forEach(i => EXP.TransitionTo(i, {'opacity': 0.2}));
		EXP.TransitionTo(transformCircle,{expr: (i,t,x,y,z) => [x,y,z-0.01]},10); //don't cover up lines

		await EXP.delay(800);

		yaxis.reveal();

		await EXP.delay(800);

		xaxis.reveal();

		await EXP.delay(800);
		EXP.TransitionTo(outputAngle,{'opacity':1},1000);
		hypotenuse.reveal();
		

	}
	animate();
  </script>
</body>
</html>
