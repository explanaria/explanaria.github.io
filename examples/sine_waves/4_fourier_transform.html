<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="shortcut icon" href="../../favicon.ico"/>
  <title>Explanarian - What the Fourier Transform does</title>
  <script src="../../src/lib/three.js"></script>
  <script src="../../src/lib/OrbitControls.js"></script>
  <script src="../../build/explanaria-bundle.js"></script>
  <script src="./commonClasses.js"></script>

  <link type="text/css" href="../../src/style.css" rel="stylesheet" />

  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
</head>
<body>
  <script>
	var three = new EXP.Threeasy_Environment(true, 120,10);
	var controls = new THREE.OrbitControls(three.camera,three.renderer.domElement);

	three.camera.position.set(0,0,10);
	three.camera.lookAt(new THREE.Vector3(0,0,0));

	console.log("Loaded.");


	var params = {};
	params.radius=4;


	class SineWave{
		constructor(frequency, amplitude, color, numItems=80){
			this.amplitude = amplitude;
			this.freq = frequency;

			let width = 12;

			this.area = new EXP.Area({bounds: [[0,width]],numItems:numItems});
			this.revealTransform  = new EXP.Transformation({'expr': (i,t,x,y) => [0,0]});

			let sineFunc = ((i,t,x) => [x,this.amplitude*Math.sin(this.freq*(t + x)),0]).bind(this);
			this.lineDefinition = new EXP.Transformation({'expr': sineFunc});
			this.postTransform = new EXP.Transformation({'expr': (i,t,x,y,z) => [x-width/2,y]});

			this.color = color;
			this.output = new EXP.LineOutput({width:5,color:this.color});

			this.area.add(this.revealTransform).add(this.lineDefinition).add(this.postTransform).add(this.output);

		}
		reveal(duration=1000){
			EXP.TransitionTo(this.revealTransform,{'expr':(i,t,x,y) => [x,y]},duration);
		}
		activate(...args){
			this.area.activate(...args);
		}
	}

	let sqFC = (w) => w%2==1 ? [w,2/w] : [w,0]; //squareFourierCoeffs, fourier coeffs of a square wave
	let sawFC = (w) => [w,Math.pow(2,-w+1)]; //squareFourierCoeffs, fourier coeffs of a square wave
	let randFC = (w) => [w,[1,2,1,1,1,2,1,0,1,2][w]];

	let genCoeffs = (func) => [func(1),func(2),func(3),func(4),func(5),func(6),func(7),func(8)];
	let genOddCoeffs = (func) => [func(1),func(3),func(5),func(7),func(9),func(11)];

	//params.freqs = genOddCoeffs(sqFC); //freq, amplitude
	params.freqs = genCoeffs(randFC); //freq, amplitude
	params.freqs = genCoeffs(sawFC);

	var totalWave = new SineWave(1, 2, orangered, three.IS_RECORDING ? 1000 : 80);
	totalWave.lineDefinition.expr = (i,t,x) => {
			let y = 0;
			for(var i=0;i<params.freqs.length;i++){
				y += params.freqs[i][1]*Math.sin(params.freqs[i][0]*(t + x));
			}
			return [x,y];
		}
	let eightBitSine = (t,x) => { // to be used with a much higher line density
		let sin = Math.sin(t+x);
		let y = Math.ceil(sin*4-0.5)/4;
		return [x, y];
	}
	//totalWave.lineDefinition.expr = (i,t,x) => eightBitSine(t,x)
	let ramp = (t,x) => [x, Math.abs(t+x) % 2]; // to be used with a much higher line density
	//totalWave.lineDefinition.expr = (i,t,x) => ramp(t,x)

	var waves = [];
	for(var i=0;i<params.freqs.length;i++){
		waves.push(new SineWave(params.freqs[i][0],params.freqs[i][1],lightblue));
	}



	var plus = new PlusSign([-6,0],1,0x000000);
	var equals = new EqualsSign([-1,0],1,0x000000);

	var sceneItems = [totalWave.area].concat(waves);
	three.on("update",function(time){
		sceneItems.map(i => i.activate(time.t));
	});

	async function animate(){

		totalWave.reveal();
		await EXP.delay(3000);
		//from sine_definition.html
		//EXP.TransitionTo(revealTransform,{'expr': (i,t,x) => [x]},1000)
		EXP.TransitionTo(totalWave.postTransform,{'expr': (i,t,x,y,z) => [(x-6)/2-6.5,y/1.5]},1000);

		await EXP.delay(1000);

		equals.addTo(sceneItems);
		await equals.reveal(500,300);
		await EXP.delay(1000);

		let maxHeight = 12; //change if this is too squished
		let xPlace = 5;

		let numWavesToDraw = 5;

		for(var i=0;i<numWavesToDraw;i++){
			let heightIncrement = maxHeight/(numWavesToDraw);
	
			let height = -i/(numWavesToDraw)*maxHeight + maxHeight/2;

			EXP.TransitionTo(waves[i].postTransform,{'expr': (i,t,x,y,z) => [(x-6)/3+xPlace,y/3 + height]},10);
			waves[i].reveal();
			await EXP.delay(800);
		
			var plus = new PlusSign([xPlace,height-heightIncrement/2],0.5,0x000000);
			plus.addTo(sceneItems);
			await plus.reveal(200,100);

			await EXP.delay(200);
		}

		let dotWidth = 0.8;
		var dotDotDot = new EXP.Array({data: [[xPlace-dotWidth, -maxHeight/2], [xPlace, -maxHeight/2], [xPlace+dotWidth, -maxHeight/2]]});
		dotDotDot.add(new EXP.PointOutput({color: 0x000000, width:0.2, opacity: 0}));
		sceneItems.push(dotDotDot);

		EXP.TransitionTo(dotDotDot.children[0], {opacity: 1},1000,300);


	}
	animate();
  </script>
</body>
</html>
